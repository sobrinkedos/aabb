/*\n  # Completar Funcionalidades de Hierarquia Administrativa\n  \n  Esta migração adiciona funcionalidades complementares para o sistema\n  de hierarquia administrativa, incluindo:\n  - Função para registrar logs de auditoria\n  - Campos adicionais para controle de sessão\n  - Triggers para logging automático\n  - Configurações de segurança avançadas\n*/\n\n-- Adicionar campos para controle de sessão e segurança\nALTER TABLE public.usuarios_empresa \nADD COLUMN IF NOT EXISTS ativo BOOLEAN DEFAULT TRUE;\n\nALTER TABLE public.usuarios_empresa \nADD COLUMN IF NOT EXISTS tem_acesso_sistema BOOLEAN DEFAULT FALSE;\n\nALTER TABLE public.usuarios_empresa \nADD COLUMN IF NOT EXISTS tentativas_login_falhadas INTEGER DEFAULT 0;\n\nALTER TABLE public.usuarios_empresa \nADD COLUMN IF NOT EXISTS bloqueado_ate TIMESTAMPTZ;\n\nALTER TABLE public.usuarios_empresa \nADD COLUMN IF NOT EXISTS total_logins INTEGER DEFAULT 0;\n\n-- Função para registrar logs de auditoria (chamada pelo backend)\nCREATE OR REPLACE FUNCTION public.registrar_log_auditoria(\n  p_empresa_id UUID,\n  p_usuario_id UUID,\n  p_acao TEXT,\n  p_recurso TEXT DEFAULT NULL,\n  p_detalhes JSONB DEFAULT NULL,\n  p_ip_address INET DEFAULT NULL,\n  p_user_agent TEXT DEFAULT NULL\n)\nRETURNS UUID\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nDECLARE\n  log_id UUID;\nBEGIN\n  INSERT INTO public.logs_auditoria (\n    empresa_id,\n    usuario_id,\n    acao,\n    recurso,\n    detalhes,\n    ip_address,\n    user_agent\n  ) VALUES (\n    p_empresa_id,\n    p_usuario_id,\n    p_acao,\n    p_recurso,\n    p_detalhes,\n    p_ip_address,\n    p_user_agent\n  ) RETURNING id INTO log_id;\n  \n  RETURN log_id;\nEND;\n$;\n\n-- Função para atualizar último login\nCREATE OR REPLACE FUNCTION public.atualizar_ultimo_login(\n  p_user_id UUID\n)\nRETURNS VOID\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nBEGIN\n  UPDATE public.usuarios_empresa \n  SET \n    ultimo_login = NOW(),\n    total_logins = total_logins + 1,\n    tentativas_login_falhadas = 0\n  WHERE user_id = p_user_id;\nEND;\n$;\n\n-- Função para registrar tentativa de login falhada\nCREATE OR REPLACE FUNCTION public.registrar_login_falhado(\n  p_email TEXT,\n  p_ip_address INET DEFAULT NULL\n)\nRETURNS VOID\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nDECLARE\n  v_usuario_empresa public.usuarios_empresa%ROWTYPE;\n  v_max_tentativas INTEGER := 5;\n  v_tempo_bloqueio INTERVAL := '30 minutes';\nBEGIN\n  -- Buscar usuário pelo email\n  SELECT ue.* INTO v_usuario_empresa\n  FROM public.usuarios_empresa ue\n  WHERE ue.email = p_email\n  LIMIT 1;\n  \n  IF FOUND THEN\n    -- Incrementar tentativas falhadas\n    UPDATE public.usuarios_empresa \n    SET tentativas_login_falhadas = tentativas_login_falhadas + 1\n    WHERE id = v_usuario_empresa.id;\n    \n    -- Se excedeu o limite, bloquear temporariamente\n    IF v_usuario_empresa.tentativas_login_falhadas + 1 >= v_max_tentativas THEN\n      UPDATE public.usuarios_empresa \n      SET bloqueado_ate = NOW() + v_tempo_bloqueio\n      WHERE id = v_usuario_empresa.id;\n      \n      -- Registrar log de bloqueio\n      PERFORM public.registrar_log_auditoria(\n        v_usuario_empresa.empresa_id,\n        NULL, -- Não há usuário logado\n        'USUARIO_BLOQUEADO_TENTATIVAS',\n        'usuarios_empresa',\n        jsonb_build_object(\n          'email', p_email,\n          'tentativas', v_usuario_empresa.tentativas_login_falhadas + 1,\n          'bloqueado_ate', NOW() + v_tempo_bloqueio\n        ),\n        p_ip_address\n      );\n    END IF;\n    \n    -- Registrar log de tentativa falhada\n    PERFORM public.registrar_log_auditoria(\n      v_usuario_empresa.empresa_id,\n      NULL,\n      'LOGIN_FALHADO',\n      'auth',\n      jsonb_build_object(\n        'email', p_email,\n        'tentativas_consecutivas', v_usuario_empresa.tentativas_login_falhadas + 1\n      ),\n      p_ip_address\n    );\n  END IF;\nEND;\n$;\n\n-- Função para verificar se usuário está bloqueado\nCREATE OR REPLACE FUNCTION public.usuario_esta_bloqueado(\n  p_user_id UUID\n)\nRETURNS BOOLEAN\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nDECLARE\n  v_bloqueado_ate TIMESTAMPTZ;\nBEGIN\n  SELECT bloqueado_ate INTO v_bloqueado_ate\n  FROM public.usuarios_empresa\n  WHERE user_id = p_user_id;\n  \n  -- Se não tem data de bloqueio ou já passou, não está bloqueado\n  IF v_bloqueado_ate IS NULL OR v_bloqueado_ate <= NOW() THEN\n    -- Limpar bloqueio se já passou\n    IF v_bloqueado_ate IS NOT NULL AND v_bloqueado_ate <= NOW() THEN\n      UPDATE public.usuarios_empresa \n      SET bloqueado_ate = NULL, tentativas_login_falhadas = 0\n      WHERE user_id = p_user_id;\n    END IF;\n    \n    RETURN FALSE;\n  END IF;\n  \n  RETURN TRUE;\nEND;\n$;\n\n-- Função para obter estatísticas de usuários (para dashboard admin)\nCREATE OR REPLACE FUNCTION public.obter_estatisticas_usuarios(\n  p_empresa_id UUID\n)\nRETURNS JSONB\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nDECLARE\n  v_stats JSONB;\nBEGIN\n  -- Verificar se usuário tem privilégio para ver estatísticas\n  IF NOT public.tem_privilegio_admin('gerenciar_usuarios') THEN\n    RAISE EXCEPTION 'Acesso negado: privilégios insuficientes';\n  END IF;\n  \n  SELECT jsonb_build_object(\n    'total_usuarios', COUNT(*),\n    'usuarios_ativos', COUNT(*) FILTER (WHERE ativo = true),\n    'usuarios_inativos', COUNT(*) FILTER (WHERE ativo = false),\n    'usuarios_com_acesso', COUNT(*) FILTER (WHERE tem_acesso_sistema = true),\n    'usuarios_por_papel', jsonb_build_object(\n      'SUPER_ADMIN', COUNT(*) FILTER (WHERE papel = 'SUPER_ADMIN'),\n      'ADMIN', COUNT(*) FILTER (WHERE papel = 'ADMIN'),\n      'MANAGER', COUNT(*) FILTER (WHERE papel = 'MANAGER'),\n      'USER', COUNT(*) FILTER (WHERE papel = 'USER')\n    ),\n    'logins_ultimo_mes', (\n      SELECT COUNT(*) \n      FROM public.usuarios_empresa \n      WHERE empresa_id = p_empresa_id \n      AND ultimo_login >= NOW() - INTERVAL '30 days'\n    )\n  ) INTO v_stats\n  FROM public.usuarios_empresa\n  WHERE empresa_id = p_empresa_id;\n  \n  RETURN v_stats;\nEND;\n$;\n\n-- Trigger para logging automático de mudanças críticas\nCREATE OR REPLACE FUNCTION public.log_mudancas_criticas()\nRETURNS TRIGGER AS $\nDECLARE\n  v_empresa_id UUID;\n  v_detalhes JSONB;\nBEGIN\n  -- Obter empresa_id\n  IF TG_TABLE_NAME = 'usuarios_empresa' THEN\n    v_empresa_id := COALESCE(NEW.empresa_id, OLD.empresa_id);\n  ELSIF TG_TABLE_NAME = 'configuracoes_empresa' THEN\n    v_empresa_id := COALESCE(NEW.empresa_id, OLD.empresa_id);\n  ELSE\n    v_empresa_id := public.get_user_empresa_id();\n  END IF;\n  \n  -- Preparar detalhes baseado na operação\n  IF TG_OP = 'INSERT' THEN\n    v_detalhes := jsonb_build_object(\n      'operacao', 'INSERT',\n      'novo_registro', row_to_json(NEW)\n    );\n  ELSIF TG_OP = 'UPDATE' THEN\n    v_detalhes := jsonb_build_object(\n      'operacao', 'UPDATE',\n      'registro_anterior', row_to_json(OLD),\n      'registro_novo', row_to_json(NEW)\n    );\n  ELSIF TG_OP = 'DELETE' THEN\n    v_detalhes := jsonb_build_object(\n      'operacao', 'DELETE',\n      'registro_removido', row_to_json(OLD)\n    );\n  END IF;\n  \n  -- Registrar log específico baseado na tabela e operação\n  IF TG_TABLE_NAME = 'usuarios_empresa' THEN\n    -- Log mudanças de papel\n    IF TG_OP = 'UPDATE' AND OLD.papel != NEW.papel THEN\n      PERFORM public.registrar_log_auditoria(\n        v_empresa_id,\n        auth.uid(),\n        'MUDANCA_PAPEL_USUARIO',\n        'usuarios_empresa',\n        jsonb_build_object(\n          'usuario_afetado', NEW.id,\n          'papel_anterior', OLD.papel,\n          'papel_novo', NEW.papel,\n          'email', NEW.email\n        )\n      );\n    END IF;\n    \n    -- Log mudanças de status\n    IF TG_OP = 'UPDATE' AND OLD.ativo != NEW.ativo THEN\n      PERFORM public.registrar_log_auditoria(\n        v_empresa_id,\n        auth.uid(),\n        CASE WHEN NEW.ativo THEN 'USUARIO_ATIVADO' ELSE 'USUARIO_DESATIVADO' END,\n        'usuarios_empresa',\n        jsonb_build_object(\n          'usuario_afetado', NEW.id,\n          'email', NEW.email\n        )\n      );\n    END IF;\n  ELSIF TG_TABLE_NAME = 'configuracoes_empresa' THEN\n    -- Log mudanças de configurações críticas\n    IF NEW.categoria IN ('seguranca', 'sistema', 'integracao') THEN\n      PERFORM public.registrar_log_auditoria(\n        v_empresa_id,\n        auth.uid(),\n        'CONFIGURACAO_CRITICA_ALTERADA',\n        'configuracoes_empresa',\n        jsonb_build_object(\n          'categoria', NEW.categoria,\n          'configuracoes_anteriores', OLD.configuracoes,\n          'configuracoes_novas', NEW.configuracoes\n        )\n      );\n    END IF;\n  END IF;\n  \n  RETURN COALESCE(NEW, OLD);\nEND;\n$ LANGUAGE plpgsql;\n\n-- Aplicar triggers de logging\nDROP TRIGGER IF EXISTS trigger_log_usuarios_criticos ON public.usuarios_empresa;\nCREATE TRIGGER trigger_log_usuarios_criticos\n  AFTER INSERT OR UPDATE OR DELETE ON public.usuarios_empresa\n  FOR EACH ROW EXECUTE FUNCTION public.log_mudancas_criticas();\n\nDROP TRIGGER IF EXISTS trigger_log_configuracoes_criticas ON public.configuracoes_empresa;\nCREATE TRIGGER trigger_log_configuracoes_criticas\n  AFTER INSERT OR UPDATE OR DELETE ON public.configuracoes_empresa\n  FOR EACH ROW EXECUTE FUNCTION public.log_mudancas_criticas();\n\n-- Criar tabela para sessões ativas (opcional, para controle avançado)\nCREATE TABLE IF NOT EXISTS public.sessoes_ativas (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  empresa_id UUID REFERENCES public.empresas(id) ON DELETE CASCADE,\n  token_hash TEXT NOT NULL,\n  ip_address INET,\n  user_agent TEXT,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  expires_at TIMESTAMPTZ NOT NULL,\n  last_activity TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Índices para sessões ativas\nCREATE INDEX IF NOT EXISTS idx_sessoes_ativas_user_id ON public.sessoes_ativas(user_id);\nCREATE INDEX IF NOT EXISTS idx_sessoes_ativas_expires_at ON public.sessoes_ativas(expires_at);\nCREATE INDEX IF NOT EXISTS idx_sessoes_ativas_empresa_id ON public.sessoes_ativas(empresa_id);\n\n-- RLS para sessões ativas\nALTER TABLE public.sessoes_ativas ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Usuários podem ver suas próprias sessões\" ON public.sessoes_ativas\n  FOR SELECT USING (user_id = auth.uid());\n\nCREATE POLICY \"Sistema pode gerenciar sessões\" ON public.sessoes_ativas\n  FOR ALL USING (user_id = auth.uid());\n\n-- Função para limpar sessões expiradas\nCREATE OR REPLACE FUNCTION public.limpar_sessoes_expiradas()\nRETURNS INTEGER\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $\nDECLARE\n  v_removidas INTEGER;\nBEGIN\n  DELETE FROM public.sessoes_ativas \n  WHERE expires_at <= NOW();\n  \n  GET DIAGNOSTICS v_removidas = ROW_COUNT;\n  \n  RETURN v_removidas;\nEND;\n$;\n\n-- Atualizar função get_user_empresa_id para ser mais robusta\nCREATE OR REPLACE FUNCTION public.get_user_empresa_id()\nRETURNS UUID\nLANGUAGE plpgsql\nSECURITY DEFINER\nSTABLE\nAS $\nDECLARE\n  v_empresa_id UUID;\nBEGIN\n  SELECT empresa_id INTO v_empresa_id\n  FROM public.usuarios_empresa \n  WHERE user_id = auth.uid()\n  AND ativo = true\n  LIMIT 1;\n  \n  RETURN v_empresa_id;\nEND;\n$;\n\n-- Comentários nas novas funções\nCOMMENT ON FUNCTION public.registrar_log_auditoria(UUID, UUID, TEXT, TEXT, JSONB, INET, TEXT) IS 'Função para registrar logs de auditoria de forma padronizada';\nCOMMENT ON FUNCTION public.atualizar_ultimo_login(UUID) IS 'Atualiza timestamp do último login e incrementa contador';\nCOMMENT ON FUNCTION public.registrar_login_falhado(TEXT, INET) IS 'Registra tentativa de login falhada e aplica bloqueio se necessário';\nCOMMENT ON FUNCTION public.usuario_esta_bloqueado(UUID) IS 'Verifica se usuário está temporariamente bloqueado';\nCOMMENT ON FUNCTION public.obter_estatisticas_usuarios(UUID) IS 'Retorna estatísticas de usuários para dashboard administrativo';\nCOMMENT ON FUNCTION public.limpar_sessoes_expiradas() IS 'Remove sessões expiradas da tabela de controle';\nCOMMENT ON TABLE public.sessoes_ativas IS 'Controle de sessões ativas para segurança avançada';\n\n-- Inserir configurações padrão para empresas existentes que não têm\nINSERT INTO public.configuracoes_empresa (empresa_id, categoria, configuracoes)\nSELECT \n  e.id,\n  categoria.nome,\n  categoria.config_padrao\nFROM public.empresas e\nCROSS JOIN (\n  VALUES \n    ('geral', '{\"tema_padrao\": \"auto\", \"idioma\": \"pt-BR\", \"timezone\": \"America/Sao_Paulo\", \"formato_data\": \"DD/MM/YYYY\", \"formato_moeda\": \"R$ 0,00\", \"moeda_padrao\": \"BRL\"}'::jsonb),\n    ('seguranca', '{\"senha_minima_caracteres\": 8, \"senha_exigir_maiuscula\": true, \"senha_exigir_numero\": true, \"tempo_sessao_minutos\": 480, \"tentativas_login_max\": 5, \"bloqueio_temporario_minutos\": 30}'::jsonb),\n    ('sistema', '{\"backup_automatico\": true, \"backup_frequencia\": \"diario\", \"backup_horario\": \"02:00\", \"cache_habilitado\": true, \"limite_usuarios\": 100}'::jsonb),\n    ('notificacoes', '{\"email_novos_usuarios\": true, \"email_tentativas_login\": true, \"email_alteracoes_config\": true, \"notificacao_browser\": true}'::jsonb),\n    ('integracao', '{\"api_keys\": {}, \"webhooks\": [], \"sincronizacao_automatica\": false}'::jsonb)\n) AS categoria(nome, config_padrao)\nWHERE NOT EXISTS (\n  SELECT 1 FROM public.configuracoes_empresa ce \n  WHERE ce.empresa_id = e.id AND ce.categoria = categoria.nome\n);\n\n-- Atualizar usuários existentes para ter os novos campos\nUPDATE public.usuarios_empresa \nSET \n  ativo = CASE WHEN status = 'ativo' THEN true ELSE false END,\n  tem_acesso_sistema = CASE WHEN user_id IS NOT NULL THEN true ELSE false END\nWHERE ativo IS NULL OR tem_acesso_sistema IS NULL;"