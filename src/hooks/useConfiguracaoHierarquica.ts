import { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from './useAuth';\nimport { supabase } from '../lib/supabase';\nimport {\n  CategoriaConfiguracaoHierarquica,\n  TodasConfiguracoes,\n  CONFIGURACOES_PADRAO,\n  CONTROLE_ACESSO_CONFIGURACOES,\n  ConfiguracaoAcesso\n} from '../types/configuracoes';\nimport { PapelUsuario } from '../types/multitenant';\n\ninterface UseConfiguracaoHierarquicaReturn {\n  configuracoes: TodasConfiguracoes;\n  isLoading: boolean;\n  isSaving: boolean;\n  error: string | null;\n  successMessage: string | null;\n  \n  // Métodos de acesso\n  temAcessoCategoria: (categoria: CategoriaConfiguracaoHierarquica) => boolean;\n  getCategoriasAcessiveis: () => CategoriaConfiguracaoHierarquica[];\n  getControleAcesso: (categoria: CategoriaConfiguracaoHierarquica) => ConfiguracaoAcesso;\n  \n  // Métodos de manipulação\n  atualizarConfiguracao: <T extends keyof TodasConfiguracoes>(\n    categoria: T,\n    campo: keyof TodasConfiguracoes[T],\n    valor: any\n  ) => Promise<boolean>;\n  \n  salvarCategoria: (categoria: CategoriaConfiguracaoHierarquica) => Promise<boolean>;\n  recarregarConfiguracoes: () => Promise<void>;\n  \n  // Validação\n  validarAlteracao: (categoria: CategoriaConfiguracaoHierarquica, senha?: string) => Promise<boolean>;\n}\n\nexport function useConfiguracaoHierarquica(): UseConfiguracaoHierarquicaReturn {\n  const { user, papel, verificarPrivilegio } = useAuth();\n  const [configuracoes, setConfiguracoes] = useState<TodasConfiguracoes>(CONFIGURACOES_PADRAO);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSaving, setIsSaving] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [successMessage, setSuccessMessage] = useState<string | null>(null);\n\n  // Verificar se tem acesso a uma categoria\n  const temAcessoCategoria = useCallback((categoria: CategoriaConfiguracaoHierarquica): boolean => {\n    if (!papel) return false;\n    \n    const controle = CONTROLE_ACESSO_CONFIGURACOES[categoria];\n    return controle.papeisPermitidos.includes(papel);\n  }, [papel]);\n\n  // Obter categorias acessíveis\n  const getCategoriasAcessiveis = useCallback((): CategoriaConfiguracaoHierarquica[] => {\n    return Object.values(CategoriaConfiguracaoHierarquica).filter(categoria => \n      temAcessoCategoria(categoria)\n    );\n  }, [temAcessoCategoria]);\n\n  // Obter controle de acesso para uma categoria\n  const getControleAcesso = useCallback((categoria: CategoriaConfiguracaoHierarquica): ConfiguracaoAcesso => {\n    return CONTROLE_ACESSO_CONFIGURACOES[categoria];\n  }, []);\n\n  // Carregar configurações do banco\n  const carregarConfiguracoes = useCallback(async () => {\n    if (!user?.empresa_id) return;\n\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const { data, error: loadError } = await supabase\n        .from('configuracoes_empresa')\n        .select('categoria, configuracoes')\n        .eq('empresa_id', user.empresa_id);\n\n      if (loadError) {\n        throw new Error(loadError.message);\n      }\n\n      // Mesclar configurações carregadas com padrões\n      const configsCarregadas = { ...CONFIGURACOES_PADRAO };\n      \n      data?.forEach(config => {\n        const categoria = config.categoria as CategoriaConfiguracaoHierarquica;\n        if (categoria in configsCarregadas) {\n          configsCarregadas[categoria] = {\n            ...configsCarregadas[categoria],\n            ...config.configuracoes\n          };\n        }\n      });\n\n      setConfiguracoes(configsCarregadas);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erro ao carregar configurações';\n      setError(errorMessage);\n      console.error('Erro ao carregar configurações:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [user?.empresa_id]);\n\n  // Validar alteração (verificar senha se necessário)\n  const validarAlteracao = useCallback(async (\n    categoria: CategoriaConfiguracaoHierarquica, \n    senha?: string\n  ): Promise<boolean> => {\n    const controle = getControleAcesso(categoria);\n    \n    // Verificar acesso\n    if (!temAcessoCategoria(categoria)) {\n      setError('Você não tem permissão para alterar esta categoria de configuração');\n      return false;\n    }\n\n    // Verificar confirmação de senha se necessário\n    if (controle.requerConfirmacaoSenha) {\n      if (!senha) {\n        setError('Esta alteração requer confirmação de senha');\n        return false;\n      }\n\n      try {\n        // Verificar senha usando Supabase Auth\n        const { error: authError } = await supabase.auth.signInWithPassword({\n          email: user?.email || '',\n          password: senha\n        });\n\n        if (authError) {\n          setError('Senha incorreta');\n          return false;\n        }\n      } catch (err) {\n        setError('Erro ao validar senha');\n        return false;\n      }\n    }\n\n    return true;\n  }, [getControleAcesso, temAcessoCategoria, user?.email]);\n\n  // Atualizar configuração específica\n  const atualizarConfiguracao = useCallback(async <T extends keyof TodasConfiguracoes>(\n    categoria: T,\n    campo: keyof TodasConfiguracoes[T],\n    valor: any\n  ): Promise<boolean> => {\n    try {\n      setError(null);\n      \n      // Atualizar estado local imediatamente\n      setConfiguracoes(prev => ({\n        ...prev,\n        [categoria]: {\n          ...prev[categoria],\n          [campo]: valor\n        }\n      }));\n\n      return true;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar configuração';\n      setError(errorMessage);\n      return false;\n    }\n  }, []);\n\n  // Salvar categoria completa no banco\n  const salvarCategoria = useCallback(async (\n    categoria: CategoriaConfiguracaoHierarquica\n  ): Promise<boolean> => {\n    if (!user?.empresa_id) {\n      setError('Usuário não autenticado');\n      return false;\n    }\n\n    try {\n      setIsSaving(true);\n      setError(null);\n      setSuccessMessage(null);\n\n      const configCategoria = configuracoes[categoria];\n      \n      // Salvar no banco\n      const { error: saveError } = await supabase\n        .from('configuracoes_empresa')\n        .upsert({\n          empresa_id: user.empresa_id,\n          categoria,\n          configuracoes: configCategoria\n        }, {\n          onConflict: 'empresa_id,categoria'\n        });\n\n      if (saveError) {\n        throw new Error(saveError.message);\n      }\n\n      // Log de auditoria\n      await supabase.from('logs_auditoria').insert({\n        empresa_id: user.empresa_id,\n        user_id: user.id,\n        acao: 'update_configuration',\n        tabela: 'configuracoes_empresa',\n        detalhes: {\n          categoria,\n          papel_usuario: papel,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      setSuccessMessage(`Configurações de ${categoria} salvas com sucesso!`);\n      \n      // Limpar mensagem após 3 segundos\n      setTimeout(() => setSuccessMessage(null), 3000);\n      \n      return true;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erro ao salvar configurações';\n      setError(errorMessage);\n      \n      // Recarregar configurações em caso de erro\n      await carregarConfiguracoes();\n      \n      return false;\n    } finally {\n      setIsSaving(false);\n    }\n  }, [user, papel, configuracoes, carregarConfiguracoes]);\n\n  // Recarregar configurações\n  const recarregarConfiguracoes = useCallback(async () => {\n    await carregarConfiguracoes();\n  }, [carregarConfiguracoes]);\n\n  // Carregar configurações na inicialização\n  useEffect(() => {\n    if (user?.empresa_id) {\n      carregarConfiguracoes();\n    }\n  }, [user?.empresa_id, carregarConfiguracoes]);\n\n  // Limpar mensagens de erro após um tempo\n  useEffect(() => {\n    if (error) {\n      const timer = setTimeout(() => setError(null), 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [error]);\n\n  return {\n    configuracoes,\n    isLoading,\n    isSaving,\n    error,\n    successMessage,\n    \n    temAcessoCategoria,\n    getCategoriasAcessiveis,\n    getControleAcesso,\n    \n    atualizarConfiguracao,\n    salvarCategoria,\n    recarregarConfiguracoes,\n    \n    validarAlteracao\n  };\n}\n\n// Hook específico para uma categoria\nexport function useConfiguracaoCategoria<T extends keyof TodasConfiguracoes>(\n  categoria: T\n) {\n  const {\n    configuracoes,\n    isLoading,\n    isSaving,\n    error,\n    successMessage,\n    temAcessoCategoria,\n    getControleAcesso,\n    atualizarConfiguracao,\n    salvarCategoria,\n    validarAlteracao\n  } = useConfiguracaoHierarquica();\n\n  const configCategoria = configuracoes[categoria];\n  const temAcesso = temAcessoCategoria(categoria as CategoriaConfiguracaoHierarquica);\n  const controleAcesso = getControleAcesso(categoria as CategoriaConfiguracaoHierarquica);\n\n  const atualizarCampo = useCallback(async (\n    campo: keyof TodasConfiguracoes[T],\n    valor: any\n  ) => {\n    return await atualizarConfiguracao(categoria, campo, valor);\n  }, [categoria, atualizarConfiguracao]);\n\n  const salvar = useCallback(async () => {\n    return await salvarCategoria(categoria as CategoriaConfiguracaoHierarquica);\n  }, [categoria, salvarCategoria]);\n\n  const validar = useCallback(async (senha?: string) => {\n    return await validarAlteracao(categoria as CategoriaConfiguracaoHierarquica, senha);\n  }, [categoria, validarAlteracao]);\n\n  return {\n    configuracao: configCategoria,\n    isLoading,\n    isSaving,\n    error,\n    successMessage,\n    temAcesso,\n    controleAcesso,\n    atualizarCampo,\n    salvar,\n    validar\n  };\n}