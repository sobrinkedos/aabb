import { Request, Response, NextFunction } from 'express';\nimport { supabase } from '../lib/supabase';\nimport { PapelUsuario } from '../types/multitenant';\nimport { rateLimitService } from '../services/rateLimitService';\n\ninterface CriticalEndpointConfig {\n  requireDoubleConfirmation?: boolean;\n  requirePasswordConfirmation?: boolean;\n  maxAttemptsPerHour?: number;\n  logLevel: 'high' | 'critical';\n  notifyAdmins?: boolean;\n  requiredRole?: PapelUsuario[];\n  description: string;\n}\n\n// Configurações para endpoints críticos\nconst criticalEndpoints: Record<string, CriticalEndpointConfig> = {\n  // Gerenciamento de usuários críticos\n  'DELETE:/api/users/:id': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 5,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN, PapelUsuario.ADMIN],\n    description: 'Exclusão de usuário'\n  },\n  'PUT:/api/users/:id/role': {\n    requireDoubleConfirmation: true,\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 10,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Alteração de papel de usuário'\n  },\n  'POST:/api/users/admin': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 3,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Criação de novo administrador'\n  },\n\n  // Configurações de segurança\n  'PUT:/api/security/password-policy': {\n    requireDoubleConfirmation: true,\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 5,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Alteração de política de senhas'\n  },\n  'PUT:/api/security/session-config': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 10,\n    logLevel: 'high',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Alteração de configurações de sessão'\n  },\n  'POST:/api/security/2fa/disable': {\n    requireDoubleConfirmation: true,\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 2,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Desabilitação de 2FA'\n  },\n\n  // Configurações do sistema\n  'POST:/api/system/backup': {\n    maxAttemptsPerHour: 5,\n    logLevel: 'high',\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Execução de backup'\n  },\n  'POST:/api/system/restore': {\n    requireDoubleConfirmation: true,\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 1,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Restauração do sistema'\n  },\n  'DELETE:/api/system/logs': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 2,\n    logLevel: 'critical',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Limpeza de logs do sistema'\n  },\n\n  // Integrações externas\n  'PUT:/api/integrations/api-keys': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 10,\n    logLevel: 'high',\n    notifyAdmins: true,\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Alteração de chaves de API'\n  },\n  'DELETE:/api/integrations/:id': {\n    requirePasswordConfirmation: true,\n    maxAttemptsPerHour: 5,\n    logLevel: 'high',\n    requiredRole: [PapelUsuario.SUPER_ADMIN],\n    description: 'Remoção de integração'\n  }\n};\n\n// Cache para tentativas recentes\nconst attemptCache = new Map<string, { count: number; resetTime: number }>();\n\n/**\n * Middleware para proteger endpoints críticos\n */\nexport const protectCriticalEndpoint = (req: Request, res: Response, next: NextFunction) => {\n  const endpointKey = `${req.method}:${req.route?.path || req.path}`;\n  const config = criticalEndpoints[endpointKey];\n  \n  if (!config) {\n    return next(); // Não é um endpoint crítico\n  }\n\n  if (!req.user) {\n    return res.status(401).json({ error: 'Usuário não autenticado' });\n  }\n\n  const { user } = req;\n\n  // Verificar papel se especificado\n  if (config.requiredRole && !config.requiredRole.includes(user.papel)) {\n    logCriticalAttempt(req, config, 'insufficient_role');\n    return res.status(403).json({ \n      error: 'Papel insuficiente para esta operação crítica',\n      required: config.requiredRole,\n      current: user.papel\n    });\n  }\n\n  // Verificar limite de tentativas por hora\n  if (config.maxAttemptsPerHour) {\n    const attemptKey = `${user.id}_${endpointKey}`;\n    const now = Date.now();\n    const hourMs = 60 * 60 * 1000;\n    \n    let attempts = attemptCache.get(attemptKey);\n    if (!attempts || now >= attempts.resetTime) {\n      attempts = { count: 0, resetTime: now + hourMs };\n    }\n    \n    if (attempts.count >= config.maxAttemptsPerHour) {\n      logCriticalAttempt(req, config, 'rate_limit_exceeded');\n      rateLimitService.recordAbuse(user.id, 'critical_endpoint', 'high');\n      \n      return res.status(429).json({\n        error: 'Limite de tentativas excedido para operação crítica',\n        resetTime: attempts.resetTime,\n        maxAttempts: config.maxAttemptsPerHour\n      });\n    }\n    \n    attempts.count++;\n    attemptCache.set(attemptKey, attempts);\n  }\n\n  // Verificar confirmação dupla se requerida\n  if (config.requireDoubleConfirmation && !req.body.doubleConfirmation) {\n    return res.status(400).json({\n      error: 'Confirmação dupla requerida',\n      message: `Esta operação (${config.description}) requer confirmação dupla. Adicione 'doubleConfirmation: true' ao corpo da requisição.`\n    });\n  }\n\n  // Verificar confirmação de senha se requerida\n  if (config.requirePasswordConfirmation) {\n    const { passwordConfirmation } = req.body;\n    \n    if (!passwordConfirmation) {\n      return res.status(400).json({\n        error: 'Confirmação de senha requerida',\n        message: `Esta operação (${config.description}) requer confirmação de senha.`\n      });\n    }\n\n    // Validar senha (implementação simplificada - em produção usar bcrypt)\n    // Aqui você validaria a senha contra o hash armazenado\n    // Por enquanto, vamos assumir que a validação é feita em outro lugar\n  }\n\n  // Log da operação crítica\n  logCriticalAttempt(req, config, 'authorized');\n\n  // Notificar administradores se configurado\n  if (config.notifyAdmins) {\n    notifyAdminsOfCriticalOperation(req, config);\n  }\n\n  next();\n};\n\n/**\n * Middleware para validar confirmação de senha\n */\nexport const validatePasswordConfirmation = async (req: Request, res: Response, next: NextFunction) => {\n  const { passwordConfirmation } = req.body;\n  \n  if (!passwordConfirmation) {\n    return res.status(400).json({ error: 'Confirmação de senha requerida' });\n  }\n\n  if (!req.user) {\n    return res.status(401).json({ error: 'Usuário não autenticado' });\n  }\n\n  try {\n    // Verificar senha usando Supabase Auth\n    const { error } = await supabase.auth.signInWithPassword({\n      email: req.user.email,\n      password: passwordConfirmation\n    });\n\n    if (error) {\n      logCriticalAttempt(req, { description: 'password_confirmation', logLevel: 'high' } as CriticalEndpointConfig, 'invalid_password');\n      return res.status(401).json({ error: 'Senha incorreta' });\n    }\n\n    next();\n  } catch (error) {\n    console.error('Erro na validação de senha:', error);\n    return res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n};\n\n/**\n * Middleware para operações que requerem múltiplas aprovações\n */\nexport const requireMultipleApprovals = (requiredApprovals: number = 2) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    const { approvals } = req.body;\n    \n    if (!approvals || !Array.isArray(approvals)) {\n      return res.status(400).json({\n        error: 'Aprovações múltiplas requeridas',\n        required: requiredApprovals,\n        message: 'Esta operação requer aprovação de múltiplos administradores'\n      });\n    }\n\n    if (approvals.length < requiredApprovals) {\n      return res.status(400).json({\n        error: 'Aprovações insuficientes',\n        required: requiredApprovals,\n        received: approvals.length\n      });\n    }\n\n    // Validar cada aprovação\n    for (const approval of approvals) {\n      if (!approval.userId || !approval.signature || !approval.timestamp) {\n        return res.status(400).json({\n          error: 'Formato de aprovação inválido',\n          message: 'Cada aprovação deve conter userId, signature e timestamp'\n        });\n      }\n\n      // Verificar se o usuário tem privilégios para aprovar\n      const { data: approver, error } = await supabase\n        .from('usuarios_empresa')\n        .select('papel')\n        .eq('user_id', approval.userId)\n        .single();\n\n      if (error || !approver) {\n        return res.status(400).json({\n          error: 'Aprovador inválido',\n          userId: approval.userId\n        });\n      }\n\n      if (![PapelUsuario.SUPER_ADMIN, PapelUsuario.ADMIN].includes(approver.papel)) {\n        return res.status(400).json({\n          error: 'Aprovador sem privilégios suficientes',\n          userId: approval.userId,\n          role: approver.papel\n        });\n      }\n    }\n\n    next();\n  };\n};\n\n/**\n * Log de tentativas em endpoints críticos\n */\nconst logCriticalAttempt = async (req: Request, config: CriticalEndpointConfig, status: string) => {\n  try {\n    await supabase.from('logs_auditoria').insert({\n      empresa_id: req.user?.empresa_id,\n      user_id: req.user?.id,\n      acao: 'critical_endpoint_access',\n      tabela: 'security',\n      detalhes: {\n        endpoint: `${req.method}:${req.path}`,\n        description: config.description,\n        status,\n        logLevel: config.logLevel,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        body: status === 'authorized' ? req.body : undefined // Log body apenas se autorizado\n      }\n    });\n  } catch (error) {\n    console.error('Erro ao registrar log crítico:', error);\n  }\n};\n\n/**\n * Notificar administradores sobre operações críticas\n */\nconst notifyAdminsOfCriticalOperation = async (req: Request, config: CriticalEndpointConfig) => {\n  try {\n    // Buscar todos os SUPER_ADMINs da empresa\n    const { data: admins, error } = await supabase\n      .from('usuarios_empresa')\n      .select('user_id, profiles!inner(email, nome)')\n      .eq('empresa_id', req.user?.empresa_id)\n      .eq('papel', PapelUsuario.SUPER_ADMIN)\n      .eq('ativo', true);\n\n    if (error || !admins) {\n      console.error('Erro ao buscar administradores para notificação:', error);\n      return;\n    }\n\n    // Criar notificação no sistema\n    const notifications = admins\n      .filter(admin => admin.user_id !== req.user?.id) // Não notificar o próprio usuário\n      .map(admin => ({\n        user_id: admin.user_id,\n        tipo: 'critical_operation',\n        titulo: 'Operação Crítica Executada',\n        mensagem: `${req.user?.email} executou: ${config.description}`,\n        dados: {\n          endpoint: `${req.method}:${req.path}`,\n          executedBy: req.user?.email,\n          timestamp: new Date().toISOString(),\n          ip: req.ip\n        }\n      }));\n\n    if (notifications.length > 0) {\n      await supabase.from('notificacoes').insert(notifications);\n    }\n\n    // Em produção, também enviaria emails ou outras notificações\n    console.log(`Notificação de operação crítica enviada para ${notifications.length} administradores`);\n  } catch (error) {\n    console.error('Erro ao notificar administradores:', error);\n  }\n};\n\n// Limpar cache de tentativas periodicamente\nsetInterval(() => {\n  const now = Date.now();\n  for (const [key, attempts] of attemptCache.entries()) {\n    if (now >= attempts.resetTime) {\n      attemptCache.delete(key);\n    }\n  }\n}, 60000); // A cada minuto