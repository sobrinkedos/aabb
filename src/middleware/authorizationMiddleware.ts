import { Request, Response, NextFunction } from 'express';
import { supabase } from '../lib/supabase';
import { PapelUsuario, PrivilegiosAdmin } from '../types/multitenant';
import { PrivilegeUtils } from '../utils/privilegeUtils';

// Estender o tipo Request para incluir informações do usuário
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        empresa_id: string;
        papel: PapelUsuario;
        privilegios: PrivilegiosAdmin;
        isPrimeiroUsuario: boolean;
      };
    }
  }
}

interface AuthorizationOptions {
  requiredRole?: PapelUsuario | PapelUsuario[];
  requiredPrivilege?: keyof PrivilegiosAdmin | (keyof PrivilegiosAdmin)[];
  requireAll?: boolean; // Para arrays, se precisa ter todos os itens
  allowSelf?: boolean; // Permite acesso se for o próprio usuário
  selfParam?: string; // Nome do parâmetro que contém o ID do usuário (ex: 'userId')
}\n\n// Cache para privilégios (5 minutos)\nconst privilegeCache = new Map<string, { data: any; timestamp: number }>();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutos\n\n// Função para limpar cache expirado\nsetInterval(() => {\n  const now = Date.now();\n  for (const [key, entry] of privilegeCache.entries()) {\n    if (now - entry.timestamp > CACHE_TTL) {\n      privilegeCache.delete(key);\n    }\n  }\n}, 60000); // Verificar a cada minuto\n\n// Middleware de autenticação base\nexport const authenticate = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'Token de acesso requerido' });\n    }\n\n    const token = authHeader.substring(7);\n    const { data: { user }, error } = await supabase.auth.getUser(token);\n\n    if (error || !user) {\n      return res.status(401).json({ error: 'Token inválido' });\n    }\n\n    // Buscar dados do usuário na empresa (com cache)\n    const cacheKey = `user_${user.id}`;\n    const cached = privilegeCache.get(cacheKey);\n    \n    let userData;\n    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {\n      userData = cached.data;\n    } else {\n      const { data: usuarioEmpresa, error: userError } = await supabase\n        .from('usuarios_empresa')\n        .select(`\n          empresa_id,\n          papel,\n          is_primeiro_usuario,\n          ativo\n        `)\n        .eq('user_id', user.id)\n        .single();\n\n      if (userError || !usuarioEmpresa) {\n        return res.status(403).json({ error: 'Usuário não encontrado na empresa' });\n      }\n\n      if (!usuarioEmpresa.ativo) {\n        return res.status(403).json({ error: 'Usuário desativado' });\n      }\n\n      userData = {\n        id: user.id,\n        email: user.email!,\n        empresa_id: usuarioEmpresa.empresa_id,\n        papel: usuarioEmpresa.papel as PapelUsuario,\n        privilegios: PrivilegeUtils.getPrivilegiosPorPapel(usuarioEmpresa.papel as PapelUsuario),\n        isPrimeiroUsuario: usuarioEmpresa.is_primeiro_usuario || false\n      };\n\n      // Armazenar no cache\n      privilegeCache.set(cacheKey, {\n        data: userData,\n        timestamp: Date.now()\n      });\n    }\n\n    req.user = userData;\n    next();\n  } catch (error) {\n    console.error('Erro na autenticação:', error);\n    return res.status(500).json({ error: 'Erro interno do servidor' });\n  }\n};\n\n// Middleware de autorização\nexport const authorize = (options: AuthorizationOptions = {}) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Usuário não autenticado' });\n    }\n\n    const { user } = req;\n    const {\n      requiredRole,\n      requiredPrivilege,\n      requireAll = false,\n      allowSelf = false,\n      selfParam = 'userId'\n    } = options;\n\n    // Verificar se é o próprio usuário (se permitido)\n    if (allowSelf && selfParam) {\n      const targetUserId = req.params[selfParam] || req.body[selfParam];\n      if (targetUserId === user.id) {\n        return next();\n      }\n    }\n\n    // Verificar papel se especificado\n    if (requiredRole) {\n      const hasRequiredRole = (() => {\n        if (Array.isArray(requiredRole)) {\n          if (requireAll) {\n            return requiredRole.every(role => user.papel === role);\n          } else {\n            return requiredRole.includes(user.papel);\n          }\n        } else {\n          return user.papel === requiredRole;\n        }\n      })();\n\n      if (!hasRequiredRole) {\n        // Log da tentativa de acesso negado\n        logAccessDenied(req, 'insufficient_role', {\n          required: requiredRole,\n          current: user.papel\n        });\n        \n        return res.status(403).json({ \n          error: 'Papel insuficiente',\n          required: requiredRole,\n          current: user.papel\n        });\n      }\n    }\n\n    // Verificar privilégio se especificado\n    if (requiredPrivilege) {\n      const hasRequiredPrivilege = (() => {\n        if (Array.isArray(requiredPrivilege)) {\n          if (requireAll) {\n            return requiredPrivilege.every(priv => user.privilegios[priv]);\n          } else {\n            return requiredPrivilege.some(priv => user.privilegios[priv]);\n          }\n        } else {\n          return user.privilegios[requiredPrivilege];\n        }\n      })();\n\n      if (!hasRequiredPrivilege) {\n        // Log da tentativa de acesso negado\n        logAccessDenied(req, 'insufficient_privilege', {\n          required: requiredPrivilege,\n          privileges: user.privilegios\n        });\n        \n        return res.status(403).json({ \n          error: 'Privilégios insuficientes',\n          required: requiredPrivilege\n        });\n      }\n    }\n\n    next();\n  };\n};\n\n// Middleware específicos para papéis comuns\nexport const requireSuperAdmin = authorize({ requiredRole: PapelUsuario.SUPER_ADMIN });\nexport const requireAdmin = authorize({ requiredRole: [PapelUsuario.SUPER_ADMIN, PapelUsuario.ADMIN] });\nexport const requireManagerOrAbove = authorize({ \n  requiredRole: [PapelUsuario.SUPER_ADMIN, PapelUsuario.ADMIN, PapelUsuario.MANAGER] \n});\n\n// Middleware específicos para privilégios comuns\nexport const requireUserManagement = authorize({ requiredPrivilege: 'gerenciar_usuarios' });\nexport const requireCompanyConfig = authorize({ requiredPrivilege: 'configuracoes_empresa' });\nexport const requireSecurityConfig = authorize({ requiredPrivilege: 'configuracoes_seguranca' });\nexport const requireSystemConfig = authorize({ requiredPrivilege: 'configuracoes_sistema' });\nexport const requireAdvancedReports = authorize({ requiredPrivilege: 'relatorios_avancados' });\nexport const requireFullAudit = authorize({ requiredPrivilege: 'auditoria_completa' });\n\n// Middleware para verificar se pode gerenciar outro usuário\nexport const canManageUser = (req: Request, res: Response, next: NextFunction) => {\n  if (!req.user) {\n    return res.status(401).json({ error: 'Usuário não autenticado' });\n  }\n\n  const targetUserId = req.params.userId || req.body.userId;\n  if (!targetUserId) {\n    return res.status(400).json({ error: 'ID do usuário alvo não fornecido' });\n  }\n\n  // Se é o próprio usuário, permitir (para algumas operações)\n  if (targetUserId === req.user.id) {\n    return next();\n  }\n\n  // Verificar se tem privilégio de gerenciar usuários\n  if (!req.user.privilegios.gerenciar_usuarios) {\n    return res.status(403).json({ error: 'Sem privilégio para gerenciar usuários' });\n  }\n\n  // Buscar papel do usuário alvo para verificar hierarquia\n  supabase\n    .from('usuarios_empresa')\n    .select('papel')\n    .eq('user_id', targetUserId)\n    .single()\n    .then(({ data: targetUser, error }) => {\n      if (error || !targetUser) {\n        return res.status(404).json({ error: 'Usuário alvo não encontrado' });\n      }\n\n      const canManage = PrivilegeUtils.podeGerenciarPapel(\n        req.user!.papel,\n        targetUser.papel as PapelUsuario\n      );\n\n      if (!canManage) {\n        logAccessDenied(req, 'insufficient_hierarchy', {\n          managerRole: req.user!.papel,\n          targetRole: targetUser.papel\n        });\n        \n        return res.status(403).json({ \n          error: 'Não é possível gerenciar usuário com papel igual ou superior' \n        });\n      }\n\n      next();\n    })\n    .catch(error => {\n      console.error('Erro ao verificar papel do usuário alvo:', error);\n      return res.status(500).json({ error: 'Erro interno do servidor' });\n    });\n};\n\n// Sistema de rate limiting baseado em papel\nconst rateLimitMap = new Map<string, { count: number; resetTime: number }>();\n\nexport const roleBasedRateLimit = (req: Request, res: Response, next: NextFunction) => {\n  if (!req.user) {\n    return next();\n  }\n\n  const { papel, id } = req.user;\n  const key = `${id}_${req.method}_${req.path}`;\n  const now = Date.now();\n  \n  // Limites por papel (requests por minuto)\n  const limits = {\n    [PapelUsuario.SUPER_ADMIN]: 1000,\n    [PapelUsuario.ADMIN]: 500,\n    [PapelUsuario.MANAGER]: 200,\n    [PapelUsuario.USER]: 100\n  };\n\n  const limit = limits[papel] || 100;\n  const windowMs = 60 * 1000; // 1 minuto\n\n  const current = rateLimitMap.get(key);\n  \n  if (!current || now > current.resetTime) {\n    rateLimitMap.set(key, {\n      count: 1,\n      resetTime: now + windowMs\n    });\n    return next();\n  }\n\n  if (current.count >= limit) {\n    return res.status(429).json({ \n      error: 'Limite de requisições excedido',\n      limit,\n      resetTime: current.resetTime\n    });\n  }\n\n  current.count++;\n  next();\n};\n\n// Função para invalidar cache de privilégios\nexport const invalidateUserCache = (userId: string) => {\n  const cacheKey = `user_${userId}`;\n  privilegeCache.delete(cacheKey);\n};\n\n// Função para log de tentativas de acesso negado\nconst logAccessDenied = async (req: Request, reason: string, details: any) => {\n  try {\n    await supabase.from('logs_auditoria').insert({\n      empresa_id: req.user?.empresa_id,\n      user_id: req.user?.id,\n      acao: 'access_denied',\n      tabela: 'authorization',\n      detalhes: {\n        reason,\n        path: req.path,\n        method: req.method,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        ...details\n      }\n    });\n  } catch (error) {\n    console.error('Erro ao registrar log de acesso negado:', error);\n  }\n};\n\n// Middleware para log de ações administrativas\nexport const logAdminAction = (action: string) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    // Executar a ação primeiro\n    const originalSend = res.send;\n    res.send = function(data) {\n      // Log apenas se a operação foi bem-sucedida\n      if (res.statusCode >= 200 && res.statusCode < 300) {\n        supabase.from('logs_auditoria').insert({\n          empresa_id: req.user?.empresa_id,\n          user_id: req.user?.id,\n          acao: action,\n          tabela: 'admin_actions',\n          detalhes: {\n            path: req.path,\n            method: req.method,\n            body: req.body,\n            params: req.params,\n            ip: req.ip,\n            userAgent: req.get('User-Agent')\n          }\n        }).then(() => {\n          console.log(`Admin action logged: ${action} by ${req.user?.email}`);\n        }).catch(error => {\n          console.error('Erro ao registrar ação administrativa:', error);\n        });\n      }\n      \n      return originalSend.call(this, data);\n    };\n    \n    next();\n  };\n};